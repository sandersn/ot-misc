import { testall, meterUnparsed, meterPattern } from "./util/testing.ts"
import type { StressMark } from "./types.ts"
import { Word } from "./word.ts"
import {
  parseFoot,
  footBin,
  wsp,
  allFeetLeft,
  allFeetRight,
  mainLeft,
  mainRight,
  wordFootLeft,
  wordFootRight,
  iambic,
  footNonFinal,
  nonFinal,
  noCoda,
  onset,
  fillOnset,
  fillNucleus,
  parseSyllable,
} from "./constraint.ts"
import { strictEqual as eq, deepEqual as equal } from "node:assert"
// Note: parseTrochaic isn't correct, but good enough for testing constraints
import { parseTrochaic } from "./word.ts"

testall("Markedness constraints", {
  parseStressEmpty() {
    equal(parseTrochaic([]), { head: undefined, contents: [] })
  },
  parseEvalOneHeavy: evaluate(parseFoot, "_", 1),
  parseEvalOneLight: evaluate(parseFoot, ".", 1),
  parseEvalFive: evaluate(parseFoot, "..'...", 3),
  parseEvalSix: evaluate(parseFoot, "..'....", 4),
  footBinEvalEmpty() {
    equal(footBin.evaluate(new Word([])), 0)
  },
  footBinEvalOneHeavy: evaluate(footBin, "_", 0),
  footBinEvalOneLight: evaluate(footBin, ".", 0),
  footBinEvalFive: evaluate(footBin, "..'...", 0),
  footBinEvalSix: evaluate(footBin, "..'....", 0),
  wspEvalEmpty: evaluate(wsp, "", 0),
  wspEvalHeavyPrimary: evaluate(wsp, "'_", 0),
  wspEvalHeavySecondary: evaluate(wsp, "`_", 0),
  wspEvalHeavyUnstressed: evaluate(wsp, "_", 1),
  wspEvalLightUnstressed: evaluate(wsp, ".", 0),
  wspEvalLightPrimary: evaluate(wsp, "'.", 0),
  wspEvalHeavyLight: evaluate(wsp, ".'_.", 0),
  wspEvalHeavyLightUnstressed: evaluate(wsp, "._.", 1),
  wspEvalMultipleHeavyUnstressed: evaluate(wsp, "__._.", 3),
  wspEvalMultipleHeavyMixed: evaluate(wsp, "__.`_.", 2),
  aflEvalEmpty: evaluate(allFeetLeft, "", 0),
  aflEvalOneUnstressed: evaluate(allFeetLeft, ".", 0),
  aflEvalOneLight: evaluate(allFeetLeft, "'.", 0),
  aflEvalOneHeavy: evaluate(allFeetLeft, "'_", 0),
  aflEvalTwo: evaluate(allFeetLeft, "'..", 0),
  aflEvalFourOneStress: evaluate(allFeetLeft, "..'..", 2),
  aflEvalFourTwoStress: evaluate(allFeetLeft, "'..'..", 2),
  aflEvalFiveTwoStressInitial: evaluate(allFeetLeft, "'...'..", 3),
  aflEvalFiveTwoStress: evaluate(allFeetLeft, ".'..'..", 4),
  afrEvalEmpty: evaluate(allFeetRight, "", 0),
  afrEvalOneUnstressed: evaluate(allFeetRight, ".", 0),
  afrEvalOneLight: evaluate(allFeetRight, "'.", 0),
  afrEvalOneHeavy: evaluate(allFeetRight, "'_", 0),
  afrEvalTwo: evaluate(allFeetRight, "'..", 0),
  afrEvalFourOneStress: evaluate(allFeetRight, "..'..", 0),
  afrEvalFourTwoStress: evaluate(allFeetRight, "'..'..", 2),
  afrEvalFiveTwoStressInitial: evaluate(allFeetRight, "'...'..", 3),
  afrEvalFiveTwoStress: evaluate(allFeetRight, ".'..'..", 2),
  mainLeftEvalEmpty: evaluate(mainLeft, "", 0),
  mainLeftEvalOneUnstressed: evaluate(mainLeft, ".", 0),
  mainLeftEvalOneLight: evaluate(mainLeft, "'.", 0),
  mainLeftEvalOneHeavy: evaluate(mainLeft, "'_", 0),
  mainLeftEvalTwo: evaluate(mainLeft, "'..", 0),
  mainLeftEvalFourOneStress: evaluate(mainLeft, "..'..", 2),
  mainLeftEvalFourTwoStress: evaluate(mainLeft, "'..'..", 2),
  mainLeftEvalFiveTwoStressInitial: evaluate(mainLeft, "'...`..", 0),
  mainLeftEvalFiveTwoStressSecondary: evaluate(mainLeft, "`...'..", 3),
  mainLeftEvalFiveTwoStressNonInitial: evaluate(mainLeft, ".'..`..", 1),
  mainLeftEvalFiveTwoStressNonInitialSecondary: evaluate(mainLeft, ".`..'..", 3),
  mainRightEvalEmpty: evaluate(mainRight, "", 0),
  mainRightEvalOneUnstressed: evaluate(mainRight, ".", 0),
  mainRightEvalOneLight: evaluate(mainRight, "'.", 0),
  mainRightEvalOneHeavy: evaluate(mainRight, "'_", 0),
  mainRightEvalTwo: evaluate(mainRight, "'..", 0),
  mainRightEvalFourOneStress: evaluate(mainRight, "..'..", 0),
  mainRightEvalFourTwoStress: evaluate(mainRight, "'..`..", 2),
  mainRightEvalFourTwoStressSecondary: evaluate(mainRight, "`..'..", 0),
  mainRightEvalFiveTwoStressInitial: evaluate(mainRight, "'...`..", 3),
  mainRightEvalFiveTwoStressNonInitial: evaluate(mainRight, ".'..`..", 2),
  mainRightEvalFiveTwoStressNonInitialSecondary: evaluate(mainRight, ".`..'..", 0),
  wflEvalEmpty: evaluate(wordFootLeft, "", 0),
  wflEvalOneUnstressed: evaluate(wordFootLeft, ".", 1),
  wflEvalOneStressed: evaluate(wordFootLeft, "'.", 0),
  wflEvalTwoNonInitial: evaluate(wordFootLeft, ".'.", 1),
  wflEvalTwoInitial: evaluate(wordFootLeft, "'..", 0),
  wflEvalFiveFinal: evaluate(wordFootLeft, "....'.", 1),
  wflEvalFiveTwoStressed: evaluate(wordFootLeft, ".'..'..", 1),
  wfrEvalEmpty: evaluate(wordFootRight, "", 0),
  wfrEvalOneUnstressed: evaluate(wordFootRight, ".", 1),
  wfrEvalOneStressed: evaluate(wordFootRight, "'.", 0),
  wfrEvalTwoNonInitial: evaluate(wordFootRight, ".'.", 0),
  wfrEvalTwoInitial: evaluate(wordFootRight, "'..", 0),
  wfrEvalFiveFinal: evaluate(wordFootRight, "....'.", 0),
  wfrEvalFiveTwoStressed: evaluate(wordFootRight, ".'..'..", 0),
  iambicEvalEmpty: evaluate(iambic, "", 0),
  iambicEvalOne: evaluate(iambic, ".", 0),
  iambicEvalTwoInitial: evaluate(iambic, "'..", 1),
  iambicEvalTwo: evaluate(iambic, ".'.", 0),
  iambicEvalFour: evaluate(iambic, "'..'..", 2),
  footNonFinalEvalEmpty: evaluate(footNonFinal, "", 0),
  footNonFinalEvalOne: evaluate(footNonFinal, ".", 0),
  footNonFinalEvalOneStress: evaluate(footNonFinal, "'.", 1),
  footNonFinalEvalTwoInitial: evaluate(footNonFinal, "'..", 0),
  footNonFinalEvalTwoFinal: evaluate(footNonFinal, ".'.", 1),
  footNonFinalEvalThree: evaluate(footNonFinal, "'..'.", 1),
  nonFinalEvalEmpty: evaluate(nonFinal, "", 0),
  nonFinalEvalOne: evaluate(nonFinal, ".", 0),
  nonFinalEvalOneStress: evaluate(nonFinal, "'.", 1),
  nonFinalEvalTwo: evaluate(nonFinal, "'..", 1),
  nonFinalEvalThreeInitial: evaluate(nonFinal, "'...", 0),
  nonFinalEvalThreeInitialSecondary: evaluate(nonFinal, "'..`.", 1),
  noCodaEmpty: evaluate(noCoda, "", 0),
  noCoda1Nucleus: evaluate(noCoda, "v.", 0),
  noCoda1CV: evaluate(noCoda, "cv.", 0),
  noCoda1CVC: evaluate(noCoda, "cvc.", 1),
  noCoda2CVCVC: evaluate(noCoda, "cv.cvc.", 1),
  noCoda2CVCCVC: evaluate(noCoda, "cvc.cvc.", 2),
  onsetEmpty: evaluate(onset, "", 0),
  onset1V: evalSegment(onset, "v.", 1),
  onset1CV: evalSegment(onset, "cv.", 0),
  onset2VCV: evalSegment(onset, "v.cv.", 1),
  parseSyllableEmpty: evalSegment(parseSyllable, "", 0),
  parseSyllable0V: evalSegment(parseSyllable, "v", 1),
  parseSyllable0CV: evalSegment(parseSyllable, "cv", 2),
  parseSyllable1V: evalSegment(parseSyllable, "v.", 0),
  parseSyllable1CV: evalSegment(parseSyllable, "cv.", 0),
})
testall("Faithfulness constraints", {
  fillOnsetEmpty: evalSegment(fillOnset, "v.", 0),
  fillOnset1TV: evalSegment(fillOnset, "tv.", 1),
  fillOnset1CVT: evalSegment(fillOnset, "cvt.", 0),
  fillOnset1TVC: evalSegment(fillOnset, "tvc.", 1),
  fillOnset1CAT: evalSegment(fillOnset, "tac.", 1),
  fillOnset1CATVT: evalSegment(fillOnset, "tac.tv.", 2),
  fillNucleusEmpty: evalSegment(fillNucleus, "", 0),
  fillNucleus1V: evalSegment(fillNucleus, "v.", 0),
  fillNucleus1A: evalSegment(fillNucleus, "a.", 1),
  fillNucleus1CA: evalSegment(fillNucleus, "ca.", 1),
  fillNucleus1CV: evalSegment(fillNucleus, "cv.", 0),
  fillNucleus1CVTCA: evalSegment(fillNucleus, "cvt.ca.", 1),
  fillNucleus1CATCA: evalSegment(fillNucleus, "cat.ca.", 2),
})
// TODO: evaluate/evalSegment need to be unified
// TODO: Rename StressMark to Constraint
function evaluate(constraint: StressMark, overt: string, count: number): () => void {
  return () => equal(constraint.evaluate(parseTrochaic(meterUnparsed(overt))), count)
}
function evalSegment(constraint: StressMark, overt: string, count: number): () => void {
  return () => equal(constraint.evaluate(meterPattern(overt)), count)
}
