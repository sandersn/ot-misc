import { testall } from "./util/testing"
import { strictEqual as eq, deepEqual as equal } from "node:assert"
import * as ot from "./ot"
import * as faith from "./faith"
import * as mark from "./mark"
import { zip } from "./util/array"
import { Tree } from "./types"
testall("Advanced OT tests", {
  genRepair() {
    equal(
      ot.genRepair("inkomai", [mark.onsetRepair], [faith.depRepair, faith.depInitRepair, faith.maxRepair]),
      new Set([
        "inkomai",
        "inkoma",
        "inkomati",
        "komai",
        "koma",
        "komati",
        "tinkomai",
        "tikoma",
        "nkomati",
        "nkomai",
        "tikomati",
        "ikomati",
        "tinkomati",
        "tinkoma",
        "tikomai",
        "ikoma",
        "ikomai",
        "nkoma",
      ]),
    )
  },
  "evaluation of candidates generated by repair"() {
    let input = "inkomai"
    let winners = Array.from(
      ot.genRepair(input, [mark.onsetRepair], [faith.depRepair, faith.depInitRepair, faith.maxRepair]),
    )
    let winnerProfiles = winners.map(output =>
      [mark.onset, faith.depIO, faith.depInitSigma, faith.maxIO].map(con => ot.evaluate(con, [input, output])),
    )
    equal(zip(winners, winnerProfiles), [
      ["inkomai", [2, 0, 0, 0]],
      ["inkoma", [1, 0, 0, 1]],
      ["inkomati", [1, 1, 0, 0]],
      ["komai", [1, 0, 0, 2]],
      ["koma", [0, 0, 0, 3]],
      ["komati", [0, 1, 0, 2]],
      ["tinkomai", [1, 1, 1, 0]],
      ["tinkoma", [0, 1, 1, 1]],
      ["tinkomati", [0, 2, 1, 0]],
      ["ikomai", [2, 0, 0, 1]],
      ["nkomai", [1, 0, 0, 1]],
      ["ikoma", [1, 0, 0, 2]],
      ["nkoma", [0, 0, 0, 2]],
      ["ikomati", [1, 1, 0, 1]],
      ["nkomati", [0, 1, 0, 1]],
      ["tikomai", [1, 1, 1, 1]],
      ["tikoma", [0, 1, 1, 2]],
      ["tikomati", [0, 2, 1, 1]],
    ])
  },
  boundingTree() {
    let input = "inkomai"
    let winners = Array.from(
      ot.genRepair(input, [mark.onsetRepair], [faith.depRepair, faith.depInitRepair, faith.maxRepair]),
    )
    let winnerProfiles = winners.map(output =>
      [mark.onset, faith.depIO, faith.depInitSigma, faith.maxIO].map(con => ot.evaluate(con, [input, output])),
    )
    let tree = ot.boundingTree(winnerProfiles)
    equal(
      tree,
      Tree(
        [1, 1, 1, 1],
        [
          Tree([1, 1, 1], [Tree([0, 3], [Tree([3]), Tree([0])]), Tree([1, 2], [Tree([3]), Tree([1])]), Tree([2, 1])]),
          Tree([1, 0, 1], [Tree([0, 3], [Tree([3]), Tree([0])]), Tree([1, 1], [Tree([3]), Tree([2])]), Tree([2, 0])]),
          Tree(
            [1, 1, 1],
            [
              Tree([1, 2], [Tree([3]), Tree([1])]),
              Tree([1, 1], [Tree([3]), Tree([2])]),
              Tree([2, 1], [Tree([1]), Tree([2])]),
            ],
          ),
          Tree([1, 1, 1], [Tree([2, 1]), Tree([2, 0]), Tree([2, 1], [Tree([1]), Tree([2])])]),
        ],
      ),
    )
    eq(ot.isBounded([2, 0, 0, 0], tree), false)
    eq(ot.isBounded([0, 0, 0, 2], tree), false)
    let bounders = zip(winners, winnerProfiles).filter(([_, profile]) => !ot.isBounded(profile, tree))
    equal(bounders, [
      ["inkomai", [2, 0, 0, 0]],
      ["inkoma", [1, 0, 0, 1]],
      ["inkomati", [1, 1, 0, 0]],
      ["koma", [0, 0, 0, 3]],
      ["komati", [0, 1, 0, 2]],
      ["tinkomai", [1, 1, 1, 0]],
      ["tinkoma", [0, 1, 1, 1]],
      ["tinkomati", [0, 2, 1, 0]],
      ["nkomai", [1, 0, 0, 1]],
      ["nkoma", [0, 0, 0, 2]],
      ["ikomati", [1, 1, 0, 1]],
      ["nkomati", [0, 1, 0, 1]],
      ["tikomai", [1, 1, 1, 1]],
    ])
    // a candidate set whose tree-bounded candidates are removed will produce the same bounding tree
    equal(ot.boundingTree(winnerProfiles.filter(profile => !ot.isBounded(profile, tree))), tree)
  },
  candidateTree() {
    equal(
      ot.candidateTree([
        ["cost][us", [1, 1, 0, 0, 0]],
        ["cos]t[us", [0, 1, 0, 0, 1]],
        ["cos][tus", [0, 0, 1, 0, 0]],
      ]),
      Tree(
        [
          [
            ["cost][us", [1, 1, 0, 0, 0]],
            ["cos]t[us", [0, 1, 0, 0, 1]],
            ["cos][tus", [0, 0, 1, 0, 0]],
          ],
          [1, 1, 1, 0, 1],
        ],
        [
          Tree(
            [
              [
                ["cos]t[us", [1, 0, 0, 1]],
                ["cos][tus", [0, 1, 0, 0]],
              ],
              [1, 1, 0, 1],
            ],
            [
              Tree([[["cos][tus", [1, 0, 0]]], []]),
              Tree([[["cos]t[us", [1, 0, 1]]], []]),
              Tree(
                [
                  [
                    ["cos]t[us", [1, 0, 1]],
                    ["cos][tus", [0, 1, 0]],
                  ],
                  [1, 1, 1],
                ],
                [
                  Tree([[["cos][tus", [1, 0]]], []]),
                  Tree([[["cos]t[us", [1, 1]]], []]),
                  Tree([[["cos][tus", [0, 1]]], []]),
                ],
              ),
              Tree([[["cos][tus", [0, 1, 0]]], []]),
            ],
          ),
          Tree([[["cos][tus", [0, 1, 0, 0]]], []]),
          Tree(
            [
              [
                ["cost][us", [1, 1, 0, 0]],
                ["cos]t[us", [0, 1, 0, 1]],
              ],
              [1, 1, 0, 1],
            ],
            [
              Tree([[["cos]t[us", [1, 0, 1]]], []]),
              Tree(
                [
                  [
                    ["cost][us", [1, 0, 0]],
                    ["cos]t[us", [0, 0, 1]],
                  ],
                  [1, 0, 1],
                ],
                [
                  Tree([[["cos]t[us", [0, 1]]], []]),
                  Tree(
                    [
                      [
                        ["cost][us", [1, 0]],
                        ["cos]t[us", [0, 1]],
                      ],
                      [1, 1],
                    ],
                    [Tree([[["cos]t[us", [1]]], []]), Tree([[["cost][us", [1]]], []])],
                  ),
                  Tree([[["cost][us", [1, 0]]], []]),
                ],
              ),
              Tree(
                [
                  [
                    ["cost][us", [1, 1, 0]],
                    ["cos]t[us", [0, 1, 1]],
                  ],
                  [1, 1, 1],
                ],
                [
                  Tree([[["cos]t[us", [1, 1]]], []]),
                  Tree(
                    [
                      [
                        ["cost][us", [1, 0]],
                        ["cos]t[us", [0, 1]],
                      ],
                      [1, 1],
                    ],
                    [Tree([[["cos]t[us", [1]]], []]), Tree([[["cost][us", [1]]], []])],
                  ),
                  Tree([[["cost][us", [1, 1]]], []]),
                ],
              ),
              Tree([[["cost][us", [1, 1, 0]]], []]),
            ],
          ),
          Tree(
            [
              [
                ["cost][us", [1, 1, 0, 0]],
                ["cos]t[us", [0, 1, 0, 1]],
                ["cos][tus", [0, 0, 1, 0]],
              ],
              [1, 1, 1, 1],
            ],
            [
              Tree(
                [
                  [
                    ["cos]t[us", [1, 0, 1]],
                    ["cos][tus", [0, 1, 0]],
                  ],
                  [1, 1, 1],
                ],
                [
                  Tree([[["cos][tus", [1, 0]]], []]),
                  Tree([[["cos]t[us", [1, 1]]], []]),
                  Tree([[["cos][tus", [0, 1]]], []]),
                ],
              ),
              Tree([[["cos][tus", [0, 1, 0]]], []]),
              Tree(
                [
                  [
                    ["cost][us", [1, 1, 0]],
                    ["cos]t[us", [0, 1, 1]],
                  ],
                  [1, 1, 1],
                ],
                [
                  Tree([[["cos]t[us", [1, 1]]], []]),
                  Tree(
                    [
                      [
                        ["cost][us", [1, 0]],
                        ["cos]t[us", [0, 1]],
                      ],
                      [1, 1],
                    ],
                    [Tree([[["cos]t[us", [1]]], []]), Tree([[["cost][us", [1]]], []])],
                  ),
                  Tree([[["cost][us", [1, 1]]], []]),
                ],
              ),
              Tree(
                [
                  [
                    ["cost][us", [1, 1, 0]],
                    ["cos][tus", [0, 0, 1]],
                  ],
                  [1, 1, 1],
                ],
                [
                  Tree([[["cos][tus", [0, 1]]], []]),
                  Tree([[["cos][tus", [0, 1]]], []]),
                  Tree([[["cost][us", [1, 1]]], []]),
                ],
              ),
            ],
          ),
          Tree(
            [
              [
                ["cost][us", [1, 1, 0, 0]],
                ["cos][tus", [0, 0, 1, 0]],
              ],
              [1, 1, 1, 0],
            ],
            [
              Tree([[["cos][tus", [0, 1, 0]]], []]),
              Tree([[["cos][tus", [0, 1, 0]]], []]),
              Tree([[["cost][us", [1, 1, 0]]], []]),
              Tree(
                [
                  [
                    ["cost][us", [1, 1, 0]],
                    ["cos][tus", [0, 0, 1]],
                  ],
                  [1, 1, 1],
                ],
                [
                  Tree([[["cos][tus", [0, 1]]], []]),
                  Tree([[["cos][tus", [0, 1]]], []]),
                  Tree([[["cost][us", [1, 1]]], []]),
                ],
              ),
            ],
          ),
        ],
      ),
    )
  },
})
